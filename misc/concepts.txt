Detect anomaly and alert defects from an unstructured data pool received from current sensors of a 3-phase induction motor at a rate of 10K - 15K instances per second. 

Dataset:
https://drive.google.com/drive/folders/1d70I-XacHhA7i7MsVQa-iFJvp2nTiayA?usp=share_link

the data set contains current readings of a 3-phase AC motor (3.2hp) 
motor current signature analysis and model-based VI analysis to be done to detect anomalies 

Structure/process the data, create condition indicators, create an ML model, and create features to train the model.  The model should learn, and predict future anomalies. 
For other data, you can get data set from kaggle or other online sources as well.

Study on MCSA, model-based VI analysis, and how they're applied to predict machine failure.

Timeline: 48hrs (from the day you receive the task)
How to submit:
Share it on GitHub or GitLab with proper documentation 
1. what you have done - logic
2. how it can be set up and tested in an isolated system (share deployable/dockerized code)
3. create an anomaly in the data set provided and show that your code can detect it (TDD testing)




Phases of current :
https://www.youtube.com/watch?v=4oRT7PoXSS0 

Two coils (on the stator, which holds the coils), up and down, Magnet rotates, disturbance in magnetic field cause 
electrons to move. Due to poles changing, the current reverses. The change is 
gradual since the fields are oval in shape and hence looks like a wave. 
1 Cycle = 1 rotation = once up and once down, freq = cycles/rotations per sec. 

1 phase : large gaps and probably not efficient. 

2 Phase : 2 more coils, 120 degrees from first 2 coils from either side (side should be same for both). 
3 Phase : add 2 more coils on the other side to the one chosen for 2 phase.


Induction Motor:
https://www.youtube.com/watch?v=AQqyGNOP_3o 
2 parts :
Stator : slots having 3 coil windings which carry 3 phase AC
Rotor : Loop of conduction material on which EMF from the coils will induce a current.
As per https://en.wikipedia.org/wiki/Lorentz_force, the coils will start to rotate.
freq of current controls the speed.
Share it on GitHub or GitLab with proper documentation 
1. what you have done - logic
2. how it can be set up and tested in an isolated system (share deployable/dockerized code)
3. create an anomaly in the data set provided and show that your code can detect it (TDD testing)


Dataset :
each file has 10000 3-phase current readings. 
There are 317 files, which means the readings were taken for 317 seconds. 
There are 3 columns in each file represent the 3 currents.
Based on the information provided, it seems unlikely that the frequency of the 
current supplied is 10K Hz, as this is much higher than the typical frequency of AC power in most regions,
which is usually around 50-60 Hz. It's possible that the data is being sampled at a rate 
of 10K-15K Hz, but this would not necessarily reflect the frequency of the current itself.

 Since each file represents one second of data and each file has 10,000 readings, 
 the sampling frequency of the data is 10,000 Hz (samples per second). 
 Therefore, the frequency resolution of the FFT would be 10,000/2 = 5000 Hz, 
 which means you can accurately detect frequencies up to 5000 Hz in the data.

The sampling frequency refers to how many times we measure the current in a given time period. In this case, we measure the current 10,000 times every second.

The frequency resolution of the FFT tells us how many different frequencies we can accurately detect in the current data. The maximum frequency we can detect accurately is half of the sampling frequency. So if the sampling frequency is 10,000 Hz, we can accurately detect frequencies up to 5,000 Hz.
This means that we can use FFT to analyze the current data and detect any frequencies up to 5,000 Hz that may indicate a problem with the motor. For example, if we detect a frequency at 1,000 Hz, we know that there is something happening with the motor at that frequency. However, if there is a frequency at 6,000 Hz, we would not be able to detect it accurately with this sampling frequency.

The code is extracting the magnitudes of the 2nd, 3rd, and 4th harmonic frequencies of the current data. These harmonic frequencies are multiples of the fundamental frequency of the AC power supply. In this case, the fundamental frequency is set to 50 Hz.
Extracting these three harmonic frequencies allows for the analysis of the distortion in the AC power signal caused by non-linear loads, such as electric motors. In particular, the 3rd harmonic can be an indicator of motor problems, as it is generated by the interaction between the stator and rotor magnetic fields in the motor. By comparing the magnitudes of these three harmonic frequencies to expected values for normal operation, it is possible to detect potential problems with the motor.


Current unbalance refers to the difference in the magnitude of the three-phase currents that are supplied to the motor. Ideally, the three phases should have equal current magnitudes, but in reality, there may be small variations due to factors such as uneven distribution of loads or imbalances in the power supply. If the current unbalance is too high, it can lead to increased heating and reduced motor efficiency.

THD is a measure of the distortion in the current waveform caused by the presence of harmonics. Harmonics are frequencies that are multiples of the fundamental frequency (50 or 60 Hz), and they can be caused by non-linear loads in the electrical system. The presence of harmonics can lead to increased heating and reduced motor efficiency.

RMS current is a measure of the effective current flowing through the motor. It takes into account both the magnitude and the duration of the current, and it is an important parameter for determining the motor's power consumption and heating.

Harmonic magnitudes refer to the amplitudes of the individual harmonics present in the current waveform. These harmonics can cause increased heating and reduced motor efficiency if their magnitudes are too high.

To better understand the significance of these parameters, let's consider an example. Suppose we have a 3-phase induction motor that is rated for 10 kW and is running at full load. If the current unbalance is 5%, the THD is 10%, and the RMS current is 20 A, we can expect the motor to consume more power and generate more heat than if these parameters were within acceptable limits.

In this case, the current unbalance of 5% indicates that one or more phases are carrying more current than the others, which can cause increased heating and reduced efficiency. The THD of 10% indicates that there are significant harmonics in the current waveform, which can also cause increased heating and reduced efficiency. The RMS current of 20 A indicates that the motor is consuming more power than it would if the current waveform were smooth and sinusoidal. Finally, the harmonic magnitudes can help identify the specific harmonics that are causing the most problems and allow for targeted corrective actions.



# The three columns most likely represent the current readings of each phase of the 3-phase AC motor.
# However, without more information about the data, it's impossible to know for sure.
This code loads the data from the specified folder, renames the columns, scales the data, trains an Isolation Forest model on the scaled data, and then uses the model to predict anomalies in new data. However, you will need to perform motor current signature analysis and model-based VI analysis to create condition indicators and features to train the ML model.

As for the three columns, they most likely represent the current readings of each phase of the 3-phase AC motor. However, without more information about the data, it's impossible to know for sure.

Motor current signature analysis (MCSA): This is a technique used to analyze the electrical signals produced by an electric motor, such as the 3-phase induction motor in your case. MCSA involves taking current readings from each phase of the motor and analyzing the frequency spectrum of these readings. By analyzing the spectrum, you can identify any anomalies or patterns that may indicate a potential fault or failure in the motor. MCSA can be used to detect various types of faults, such as broken rotor bars, bearing defects, and winding faults.

Model-based VI analysis: VI stands for vibration and current analysis, and this is another technique used to detect anomalies in electric motors. Model-based VI analysis involves creating a mathematical model of the motor and using it to predict the expected behavior of the motor's electrical and mechanical signals. Any deviations from the expected behavior can then be flagged as potential anomalies. This technique is particularly useful for detecting faults in the mechanical components of the motor, such as bearings and gears.

Once you have performed MCSA and model-based VI analysis on your data, you can create condition indicators and features that can be used to train an ML model. Condition indicators are parameters that reflect the health of the motor, such as vibration levels or temperature readings, while features are specific characteristics of the data that can be used to train a model to predict anomalies. Some examples of features that could be extracted from your data include frequency spectrum peaks, statistical properties of the data, and time-domain features. By combining MCSA, model-based VI analysis, and feature engineering, you can create a robust ML model that can accurately predict anomalies in your 3-phase induction motor.




Motor Current Signal analysis : Observing frequency spectrum to identify anomalies
Vib and current analysis : Create a mathematical model that predicts normal behaviour.
Any deviation can be flagged as potential anomalies 





How to detect anomalies from peak_freqs = np.argmax(fft_data, axis=1)
mean_currents = np.mean(df, axis=1)?

Please write in English language.
Once you have extracted the frequency spectrum peaks and mean currents from your data using the code peak_freqs = np.argmax(fft_data, axis=1) and mean_currents = np.mean(df, axis=1), respectively, you can use these features to detect anomalies in the motor.

There are various ways to detect anomalies, but one common method is to use a statistical approach based on the distribution of the feature values. For example, you could calculate the mean and standard deviation of the feature values and define a threshold for detecting anomalies based on how many standard deviations away from the mean a value is. Any feature values that fall outside this threshold would be flagged as potential anomalies.

Here's an example of how you could detect anomalies in the peak frequency data using this approach:

makefile
Copy code
import numpy as np

# Calculate mean and standard deviation of peak frequency data
mean_freq = np.mean(peak_freqs)
std_freq = np.std(peak_freqs)

# Define threshold for detecting anomalies
thresh_freq = mean_freq + 3 * std_freq

# Identify potential anomalies
anomalies_freq = np.where(peak_freqs > thresh_freq)[0]
This code calculates the mean and standard deviation of the peak frequency data and defines a threshold for detecting anomalies as three standard deviations away from the mean. Any peak frequency values that fall outside this threshold are identified as potential anomalies and stored in the anomalies_freq array.

You can use a similar approach to detect anomalies in the mean current data or any other features you extract from your data. However, keep in mind that the choice of threshold and statistical method may vary depending on your specific application and dataset, and you may need to adjust these parameters based on your domain knowledge and the performance of your ML model.


FFT (Fast Fourier Transform) is used to convert a signal from time domain to frequency domain. In this context, by using FFT on the current sensor data, we can identify the frequencies at which the current is changing. This is because when a machine is running properly, the current will have a predictable pattern of frequency changes. If an anomaly occurs, it can often be detected by changes in the frequency spectrum of the current. Therefore, by using FFT, we can identify potential anomalies by examining the frequency spectrum of the current data.

MCSA is a technique used to detect faults in induction motors by analyzing the current signals that the motors produce. In a healthy motor, the current signals should be smooth and sinusoidal. However, when there is a fault in the motor, the current signals can become distorted, and the shape of the signal can change.

One common fault that MCSA can detect is broken rotor bars. Broken rotor bars can cause the current signals in the motor to become uneven, and the difference in current readings between different phases of the motor can increase. 
The equation BrokenRotorBars = abs(current_1) - abs(current_2) calculates this difference in current readings between phases 1 and 2, which can be used as a condition indicator for broken rotor bars.

Bearing faults can also be detected using MCSA. When there is a fault in a motor bearing, the current signals can become noisy, and the difference in current readings between different phases of the motor can change. 
The equation BearingFault = abs(current_2) - abs(current_3) calculates this difference in current readings between phases 2 and 3, which can be used as a condition indicator for bearing faults.

Finally, eccentricity is a fault that can occur when the motor's rotor is not perfectly centered in the stator. 
This can cause the current signals to become uneven, and the difference in current readings 
between different phases of the motor can change. The equation Eccentricity = abs(current_3) - abs(current_1) calculates this difference in current readings between phases 3 and 1, which can be used as a condition indicator for eccentricity faults.

Detect anomaly and alert defects from an unstructured data pool received from current sensors of a 3-phase induction motor at a rate of 10K - 15K instances per second. 
the data set contains current readings of a 3-phase AC motor (3.2hp).



Isolation Forest:
Isolation Forest is an unsupervised machine learning algorithm that separates anomalies from the normal data by building an ensemble of isolation trees. It works by randomly selecting a feature and then randomly selecting a split value between the maximum and minimum values of the selected feature. This process is repeated recursively until all data points are isolated in their own individual trees. Anomalies are identified as those data points that require fewer splits to be isolated, as they are expected to be more distinct compared to normal data points. Isolation Forest is efficient and can handle large datasets, but it may not perform well with high-dimensional data.

Local Outlier Factor (LOF):
LOF is a density-based algorithm that identifies outliers by comparing the density of a point to its neighbors. The density of a point is defined as the inverse of the average distance between the point and its k nearest neighbors. Anomalies are identified as those data points with a significantly lower density compared to their neighbors. LOF is efficient and can handle complex data distributions, but it may not perform well with high-dimensional data or when the data has a uniform distribution.



# Add a docstring to the class and all methods to describe their functionality, parameters, and return values. This will make it easier for other developers to understand and use the code.

# Rename the class to something more descriptive, such as "ElectricalFeatureExtractor."

# Add type hints to all method parameters and return values to improve readability and maintainability.

# Use more descriptive variable names. For example, "df" could be renamed to "current_data," "fs" could be renamed to "sampling_rate," and "funda_freq" could be renamed to "fundamental_frequency."

# Add error handling to handle unexpected inputs or errors. For example, if the input current data has a different shape than expected, the code could raise a ValueError.

# Use a consistent naming convention for variables and methods. For example, all method names could be in lowercase with underscores between words.

# Use a consistent formatting style throughout the code, such as PEP8.




How to do motor current signature analysis and model-based VI analysis to be done to detect anomalies in python on the given dataset

Performing motor current signature analysis and model-based VI analysis in Python can be done using various libraries and tools. Here are some steps you could follow to perform these analyses on your given dataset:

Load the data: You can use the pandas library to read in the text files in your data folder and combine them into a single dataframe.
python
Copy code
import pandas as pd

df = pd.concat([pd.read_csv(f, header=None) for f in datafolder])
Perform motor current signature analysis: You can use the scipy library to perform Fourier transforms on the current readings from each phase of the motor and plot the resulting frequency spectra. This will help you identify any anomalies or patterns in the spectra that may indicate a fault in the motor.
python
Copy code
from scipy.fft import fft

fft_data = fft(df)
Perform model-based VI analysis: To perform model-based VI analysis, you will need to create a mathematical model of the motor that takes into account both its electrical and mechanical behavior. This can be done using tools like MATLAB/Simulink or Python libraries like pyEMD. Once you have created the model, you can use it to predict the expected behavior of the motor's electrical and mechanical signals and compare it to the actual behavior to detect any anomalies.
scss
Copy code
import pyEMD

emd = pyEMD.EMD()

imfs = emd(df)
Create condition indicators and features: Based on the results of your MCSA and model-based VI analyses, you can create condition indicators and features that can be used to train an ML model. For example, you might extract frequency spectrum peaks, statistical properties of the data, or time-domain features.
python
Copy code
import numpy as np

peak_freqs = np.argmax(fft_data, axis=1)
mean_currents = np.mean(df, axis=1)
By following these steps, you can perform motor current signature analysis and model-based VI analysis on your dataset in Python and extract relevant features for training an ML model to detect anomalies in the motor. However, keep in mind that these analyses can be complex and require domain expertise to perform effectively.






# Import necessary libraries
import pandas as pd
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler

# Load data into a Pandas dataframe
df = pd.concat([pd.read_csv(f, header=None) for f in datafolder])

# Rename columns
df.columns = ['Current 1', 'Current 2', 'Current 3']

# Perform motor current signature analysis and model-based VI analysis to detect anomalies
# Create condition indicators and features to train an ML model
# ...

# Scale the data
scaler = StandardScaler()
scaled_df = scaler.fit_transform(df)

# Train an Isolation Forest model on the scaled data
model = IsolationForest(n_estimators=100, contamination=0.01)
model.fit(scaled_df)

# Use the trained model to predict anomalies in new data
# ...




Basic Approach :
A dataset has been provided which contains current readings of a 3-phase AC motor (3.2hp) 
Each file represents readings taken in 1 second. Each file has 10000 3-phase current readings. 
There are 317 files, which means the readings were taken for 317 seconds. 
There are 3 columns in each file represent the 3 currents.

We have to Detect anomaly and alert defects from an unstructured data pool 
received from current sensors of a 3-phase induction motor at a rate of 10K - 15K 
instances per second. 
We can create a model based on given data which can monitor real time similar to given data,
 which are and can predict if the reading are anomalous.


R 1 :
Introduction:
In this project, we will create a model using Python to detect anomalies and alert defects in a 3-phase AC motor. We will use the given dataset which contains current readings of the motor. Each file represents readings taken in 1 second and has 10000 3-phase current readings. We have to create a model that can monitor real-time data and detect if the readings are anomalous.

Data Preprocessing:
Before creating a model, we need to preprocess the data. We will start by merging all the files into a single dataframe. We will use the Pandas library for this task. Then, we will check if there are any missing values in the data. If there are any, we will impute them using the mean or median of the column.

Next, we will normalize the data to have a mean of 0 and standard deviation of 1. We will use the StandardScaler class from the Scikit-learn library for this task.

Model Creation:
We will use an autoencoder neural network to detect anomalies in the data. An autoencoder is an unsupervised learning algorithm that learns to reconstruct the input data. We will train the autoencoder on the normalized data.

We will use the Keras library to create the autoencoder. The autoencoder will have an input layer with 3 neurons, which will be the number of columns in the data. The hidden layer will have 2 neurons, and the output layer will have 3 neurons. The loss function for the autoencoder will be the mean squared error, and the optimizer will be Adam.

Training and Validation:
We will split the data into training and validation sets. We will use 80% of the data for training and 20% for validation. We will train the autoencoder for 100 epochs.

Once the autoencoder is trained, we will use it to predict the reconstructed data for both the training and validation sets. We will calculate the mean squared error between the input data and the reconstructed data. We will use this error as a measure of how anomalous the data is.

Anomalies Detection:
We will define a threshold for the mean squared error. If the mean squared error is above the threshold, we will consider the data as anomalous. We will use the validation set to determine the threshold. We will calculate the mean and standard deviation of the mean squared error for the validation set. We will set the threshold to be the mean plus three times the standard deviation.

Real-time Monitoring:
To monitor real-time data, we will read the data from the sensors and preprocess it in the same way as we did for the training data. We will then pass the normalized data through the autoencoder and calculate the mean squared error. If the mean squared error is above the threshold, we will alert the operator that there is a defect in the motor.

Conclusion:
In this project, we have created a model using Python to detect anomalies and alert defects in a 3-phase AC motor. We used an autoencoder neural network to learn the pattern of the normal data and detect anomalies. We trained the model on the given dataset and used the validation set to determine the threshold for anomaly detection. We then used the model to monitor real-time data and alert defects if the readings were anomalous.


R 2 :
Anomaly detection on a dataset containing 3 phase induction motor current readings involves identifying abnormal behavior or deviations from normal operating conditions. In this case, we have a dataset of current readings of a 3-phase AC motor (3.2hp). The dataset consists of 317 files, each representing readings taken in 1 second, with 10000 readings in each file. There are 3 columns in each file representing the 3 currents.

To perform anomaly detection on this dataset, we can follow the following steps:

Data Preprocessing: The first step is to preprocess the data by combining all the files into one dataset. This can be achieved by reading each file and appending the data to a single dataframe. Once we have a single dataframe, we can check for missing or incomplete data and handle them appropriately.

Feature Extraction: After preprocessing, the next step is to extract features from the dataset. Features are characteristics or attributes of the data that can be used to distinguish normal from anomalous behavior. In this case, we can extract statistical features such as mean, variance, and standard deviation of each current reading over time.

Model Selection: The next step is to select a suitable model for anomaly detection. Various models can be used for this purpose, such as Support Vector Machines (SVMs), Neural Networks, or Gaussian Mixture Models (GMMs). In this case, GMMs can be used to model the distribution of normal behavior, and any deviation from this distribution can be considered an anomaly.

Model Training: Once a suitable model is selected, the next step is to train the model using the extracted features. We can use the expectation-maximization algorithm to estimate the parameters of the GMM. The training dataset should consist of only normal data to learn the normal behavior of the motor.

Model Evaluation: After training the model, the next step is to evaluate its performance using a separate evaluation dataset. The evaluation dataset should consist of both normal and anomalous data. The model should be able to correctly identify the anomalous data as anomalies while minimizing false positives.

Real-time Monitoring: Finally, we can use the trained model for real-time monitoring of the 3-phase AC motor. Current readings can be continuously fed into the model, and any deviation from the learned normal behavior can be flagged as an anomaly. The operator can be alerted when an anomaly is detected, and appropriate action can be taken to avoid potential damage to the motor.

In conclusion, performing anomaly detection on a dataset containing 3-phase induction motor current readings involves preprocessing the data, extracting relevant features, selecting a suitable model, training and evaluating the model, and finally, using the model for real-time monitoring of the motor.


Corresponding code to r 2: 
code r1: 
To implement anomaly detection on the dataset containing 3-phase induction motor current readings, we can follow the following Python code:

Step 1: Data Preprocessing
import pandas as pd
import glob

read all csv files and concatenate into one dataframe
path = 'path/to/files/'
all_files = glob.glob(path + "*.csv")
df = pd.concat((pd.read_csv(f) for f in all_files))

check for missing or incomplete data and handle appropriately
df.dropna(inplace=True)

Step 2: Feature Extraction
features = df.groupby(df.index // 10000).agg(['mean', 'var', 'std'])

Step 3: Model Selection
from sklearn.mixture import GaussianMixture

initialize GMM model
gmm = GaussianMixture(n_components=1, covariance_type='full')

Step 4: Model Training
train model using expectation-maximization algorithm
gmm.fit(features)

Step 5: Model Evaluation
create evaluation dataset
eval_df = pd.concat([features.sample(frac=0.5), df.sample(frac=0.5)])

predict anomalies
anomaly_threshold = gmm.score_samples(eval_df) < -3
eval_df['anomaly'] = anomaly_threshold.astype(int)

calculate precision and recall
true_positives = eval_df[(eval_df['anomaly'] == 1) & (eval_df['label'] == 1)].shape[0]
false_positives = eval_df[(eval_df['anomaly'] == 1) & (eval_df['label'] == 0)].shape[0]
false_negatives = eval_df[(eval_df['anomaly'] == 0) & (eval_df['label'] == 1)].shape[0]
precision = true_positives / (true_positives + false_positives)
recall = true_positives / (true_positives + false_negatives)

Step 6: Real-time Monitoring
continuously feed current readings into the model
while True:
current_readings = get_current_readings()
current_features = pd.DataFrame([current_readings]).agg(['mean', 'var', 'std'])
is_anomaly = gmm.score_samples(current_features) < -3
if is_anomaly:
alert_operator()

In this code, we first preprocess the data by concatenating all the files into one dataframe and handling missing or incomplete data. Then, we extract statistical features such as mean, variance, and standard deviation of each current reading over


r 3 : 
To perform anomaly detection on a dataset containing 3 phase induction motor current readings, the following steps can be taken:

Data pre-processing: Combine all 317 files into a single dataset. Each file has 10000 readings in 3 columns. This will result in a dataset of size 3,170,000 (10000 * 3 * 317) rows and 3 columns.

Feature engineering: Calculate statistical features such as mean, standard deviation, and range for each column of the dataset. These features can be used to detect anomalies in the data.

Model selection: Select a suitable model for anomaly detection. Some commonly used models for anomaly detection include One-Class SVM, Isolation Forest, and Local Outlier Factor. Based on the size and nature of the dataset, one of these models can be selected.

Model training: Train the selected model on the pre-processed dataset. As there is no test data available, a portion of the dataset can be used as validation data to evaluate the model's performance.

Anomaly detection: Once the model is trained, it can be used to detect anomalies in real-time data. New data can be pre-processed and fed to the trained model for anomaly detection. If an anomaly is detected, an alert can be generated to notify the operator.

Model evaluation: Although there is no test data available, the model's performance can be evaluated by inspecting the detected anomalies and checking their validity.

By following these steps, anomaly detection can be performed on a dataset containing 3 phase induction motor current readings. This can lead to improved maintenance and efficiency of the motor, as well as increased safety.

